---
layout:     post                    # 使用的布局（不需要改）
title:      进程之间通讯(IPC,interprocess communication)              # 标题 
subtitle:   函数接口                #副标题
date:       2018-01-10              # 时间
author:     GR                      # 作者
header-img: img/post-bg-rwd.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - Linux
    - PCI
---

# **进程之间通讯(IPC,interprocess communication)** #

## **管道** ##

管道是内核维护的一种特殊的文件，主要用来作为进程间传递数据的主要方式，分为无名管道和命名管道(FIFO)。在`shell`里面的一些过滤程序，就是管道，比如`|grep`。

>管道是由内核管理的一个缓冲区，相当于我们放入内存中的一个纸条。管道的一端连接一个进程的输出。这个进程会向管道中放入信息。管道的另一端连接一个进程的输入，这个进程取出被放入管道的信息。一个缓冲区不需要很大，它被设计成为环形的数据结构，以便管道可以被循环利用。当管道中没有信息的话，从管道中读取的进程会等待，直到另一端的进程放入信息。当管道被放满信息的时候，尝试放入信息的进程会等待，直到另一端的进程取出信息。当两个进程都终结的时候，管道也自动消失。



### 无名管道 ###

1. 创建匿名管道的函数：
    ```C
    #include <unistd.h>
    int pipe(int fd[2]);
    ```

    + 功能：创建一个匿名管道  

    + 参数：fd[2]用来返回管道两端的文件描述符；  

        + fd[0]：指向无名管道读端；   

        + fd[1]：指向无名管道的写端。  

    + 返回值： 

        + 成功：返回0；   

        + 失败：返回-1，将错误记录在errno中。

2. 管道的实现过程：

    +  父进程使用函数`pipe`创建一个管道，得到两个文件描述符，`fd[0],fd[1]`前者用来读，后者用来写。分别代表了管道的读端和写端。如下图所示：  

    ![pipe1][]  

    + 父进程`fork`一个子进程，由于子进程复制了父进程的文件描述符，因此同一个管道同时有两个读端和写端，如下图所示： 

        ![pipe2][]  

    + 关闭不需要的读端和写端，这个的根据子进程和父进程谁读谁写来决定。最终，管道只有一个读端，一个写端，数据从写端流到读端。父进程写子进程读的情况如下：    

        ![pipe3][]

3. 匿名管道特点：

    + 管道通信是单向的，有固定的读端和写端。   

    + 数据被进程从管道读出后，在管道中该数据就不存在了。 

    + 当进程去读取空管道的时候，进程会阻塞。   

    + 当进程往满管道写入数据时，进程会阻塞。   

    + 管道容量为64KB（#define PIPE_BUFFERS 16 include/linux/pipe_fs_i.h）

4. 对匿名管道的读写：

    
    + 创建好的管道，如果写端被关闭，则读端在读完数据之后，`read`返回0，表示文件结束。  

    + 写一个读端已经被关闭的管道，会产生`SIGPIPE`信号，如果自己使用`signal`定义了对该信号的处理函数，或者忽略，则`write`会返回-1，并且将errno设置为`EPIPE`。   

    + 常量`PIPE_BUF`规定了内核缓冲区的大小，当读写的数据小于这个值，则读写操作都是原子的，不会被其他同时对这个管道读写的操作交叉。


5. 匿名管道的局限性：

    +  一般情况下是半双工的(数据只能在一个方向上流动)，有的系统也提供全双工的管道。  

    +  只能是由共同祖先的两个进程之间通信，一般用于父子进程之间。

6. 标准I/O库提供的创建方法：
    ```C
    #include <stdio.h>
    FILE* popen(const char* cmdstring, const char* type);
    ```
    + 功能：父进程以`type`的权限创建一个管道，并在子进程中执行`cmdstring`指令，并将子进程的管道连接到标准输入(`type = w`)，标准输出(`type = r`)。`popen`先调用`fork`创建子进程，在子进程中调用exec函数执行`cmdstring`。

        + `cmdstring`由`shell`执行`shell -c cmdstring`

        ![popen1][]

        ![popen2][]

    + 参数：

        + `cmdstring`：实际上调用的是`excel("/bin/sh","sh", "-c","cmdstring",NULL);`

        + `type`：只能是读或者写，针对父进程创建管道返回的`FILE*`指针对应文件的权限。

    + 返回值：

        + 成功：一个文件指针。

        + 失败： 返回NULL.
7. 标准I/O库提供的关闭方法
    ```C
    #include <stdio.h>
    int pclose(FILE *fp);
    ```

    + 功能：关闭管道，等待子进程结束的`waitpid()`就在这里实现。

    + 返回值：

        + 成功：返回`cmdstring`的终止向状态

        + 失败：返回-1
 
### 协同进程 ###

    ![coprocess][]

1. 协同进程就是他的输入输出都被管道连接到同一个进程的过滤程序。
    ```C
    //copress.c
    #include <stdio.h>
    #include <unistd.h>
    #include <stdlib.h>
    #include <string.h>
    #include <signal.h>
    #include <errno.h>
    #define LINE_MAX 100
    #define info() {                                                              \
        FILE* fp = fopen("add2.log","a+");                                        \
        if(fp == NULL)                                                            \
            exit(-1);                                                             \
        fprintf(fp, "%s func  %s, line  %d: ",__FILE__, __FUNCTION__, __LINE__ ); \
        fprintf(fp, ": %s\n", strerror(errno));                                   \
        fprintf(fp, "fp: %d\n",stdin->_fileno);                                   \
        fflush(fp);                                                               \
    }
    void handler(int signo){
        printf("caught sigpipe\n");
    }
    int main(){
        int fd1[2],fd2[2];
        pid_t pid;
        char line[LINE_MAX +1];
        if(signal(SIGPIPE, handler) == SIG_ERR){
            perror("signal error");
        }
        if(pipe(fd1) < 0 || pipe(fd2)){
            perror("Create Pipe Error");
        }
        if((pid = fork()) < 0){
            perror("Fork Error");
        }
        else if(pid > 0){
            // parent  
            close(fd1[0]);
            close(fd2[1]);
            while(fgets(line, LINE_MAX,stdin) != NULL){
                info();
                int n = strlen(line);
                if(write(fd1[1],line,n) != n){
                    perror("Parent Write Error");
                }
                // sleep(2);
                info();
                if((n = read(fd2[0], line, LINE_MAX)) < 0){
                    perror("Parent Read Error");
                }
                if(n == 0){
                    printf("child closed pipe\n");
                    break;
                }
                info();
                line[n] = 0;
                if(fputs(line, stdout) == EOF){
                    perror("Parent Stdout Error");
                }
                info();
            }
            if(ferror(stdin)){
                printf("fets error\n");
            }
            exit(0);
        }
        else{
            //child
            close(fd1[1]);
            close(fd2[0]);
            if(fd1[0] != STDIN_FILENO){
                if(dup2(fd1[0],STDIN_FILENO) != STDIN_FILENO){
                    exit(-1);
                }
                close(fd1[0]);
            }
            if(fd2[1] != STDOUT_FILENO){
                if(dup2(fd2[1],STDOUT_FILENO) != STDOUT_FILENO){
                    exit(-1);
                }
                close(fd2[1]);
            }
            execl("./add2","add2",(char*)0);
            exit(-1);
        }
        return 0;
    }
    //add2.c
    #include <stdio.h>
    #include <stdlib.h>
    #include <unistd.h>
    #include <string.h>
    #include <errno.h>
    #include <syslog.h>
    #define LINE_MAX 100
    #define info() {                                                              \
        FILE* fp = fopen("add2.log","a+");                                        \
        if(fp == NULL)                                                            \
            exit(-1);                                                             \
        fprintf(fp, "%s func  %s, line  %d: ",__FILE__, __FUNCTION__, __LINE__ ); \
        fprintf(fp, ": %s\n", strerror(errno));                                   \
        fprintf(fp, "fp: %d\n",stdin->_fileno);                                   \
        fflush(fp);                                                               \
    }
    // 自己写的例子
    int main(){
        char line[LINE_MAX+1];
        int int1,int2;
        info();
        while(fgets(line,LINE_MAX,stdin) != NULL){
            info();
            if(sscanf(line,"%d%d",&int1,&int2) == 2){
                info()
                sprintf(line,"%d\n", int1 + int2);
                info();
                line[strlen(line)] = '\0';
                if(fputs(line,stdout) == EOF){ 
                    perror("Fputs Error");
                }
                //由于管道是全缓冲，如果不刷新，则有不会立即写在管道缓冲区里面，导致父进程读不到数据而阻塞，同时，本程序下一次获取数据时候也得不到数据而阻塞，导致死锁
                fflush(stdout); 
                info();
            }
            else{
                info();
                printf("invalid parameter.\n");
                fflush(stdout);
                // write(STDOUT_FILENO, "invalid parameter\n",18);
                info();
            }
        }
        info();
        exit(0);
    }
    //apue书上例子
    // int main(){
    //     char line[LINE_MAX+1];
    //     int int1,int2,n;
    //     info();
    //     while((n = read(STDIN_FILENO, line, LINE_MAX)) > 0){
    //         line[n] = 0;
    //         info();
    //         if(sscanf(line,"%d%d",&int1,&int2) == 2){
    //             sprintf(line,"%d\n", int1 + int2);
    //             n = strlen(line);
    //             if(write(STDOUT_FILENO, line,n) != n){
    //                 perror("Fputs Error");
    //             }
    //             info();
    //         }
    //         else{
    //             info();
    //             perror("invalid parameter.");
    //         }
    //     }
    //     exit(0);
    // }
    ```


### 命名管道(FIFO) ###

1. 命名管道是一种可以在非亲缘进程之间进行通信的一种方式。命名管道类似于匿名管道，都是有内核维护的一块缓冲区，不在文件系统之中，文件系统知识记录了命名管道的路劲，因此可以在任意两个进程之间使用。

2. 创建有名管道：
    ```C
        #include <sys/types.h>
        #include<sys/stat.h>
        int mkfifo(const char *pathname, mode_t mode)
    ```
    + 函数功能：创建有名管道(FIFO文件)。创建命名管道之后要打开才能使用。

    + 参数说明：

        + `const char *pathname`：文件名(可以带路径)；

        + `mode_t mode`：创建FIFO文件的访问权限。设置用户、组群、其他的权限(0666)
        + 返回值：

            + 创建成功：返回0；

            + 创建失败：返回-1，同时将错误记录在errno。

3. 创建有名管道：
    ```C
        #include <sys/stat.h>
        #include <fcntl.h> //定义了 AT_*常量
        mkfifoat(int fd, const char* pathname, mode_t mode);
    ```
    + 函数功能：创建有名管道(FIFO文件)。

    + 参数说明：

        - 待查看的文件名是由`fd`和`pathname`共同决定的。

            - 如果`pathname`是个绝对路径，则忽略`fd`参数

            - 如果`pathname`是个相对路径路径，且 `fd=AT_FDCWD`，则在当前工作目录的路径下查找`pathname`

            - 如果`pathname`是个相对路径路径，且 `fd!=AT_FDCWD`，则在`fd`对应的打开目录下查找`pathname`

        + `mode_t mode`：创建FIFO文件的访问权限。一般为只读(O_RDONLY)，只写(O_WR_ONLY)，可以设置非租塞模式。

    + 返回值：

            + 创建成功：返回0；

            + 创建失败：返回-1，同时将错误记录在errno。

    + 命名管道的打开，读, 写就和正常的文件的读写是一样的。可以使用第三章的函数来操作。

4. 删除命名管道在文件系统中的记号：

        + `int unlink(const char *pathname);`

            + 头文件：`#include <unistd.h>`

            + 函数功能：从文件系统删除文件名。实际管道的缓冲区有内核管理，进程结束会自动删除。

            + 参数说明：

            + 返回值：   

                + 创建成功：返回0；

                + 创建失败：返回-1，同时将错误记录在errno。             

5. 命名管道打开规则：

    + `open`设置了非阻塞标志`O_NONBLOCK`

        + 读打开：若已经有相应进程写打开FIFO，则当前打开操作将成功返回，否则成功返回。

        + 写打开：若已经有相应进程读打开FIFO，则当前打开操作将成功返回，否则打开失败，返回错误`ENXIO`

    + `open`没有设置非阻塞标志`O_NONBLOCK`

        + 读打开：若已经有相应进程写打开FIFO，则当前打开操作将成功返回，否则阻塞到有进程写打开为止。

        + 写打开：若已经有相应进程读打开FIFO，则当前打开操作将成功返回，否则阻塞到有进程读打开为止。


4. 命名管道的读写操作规则：

    + 命名管道只有读端和写端都打开的时候才能进行数据传输，否则一般情况下会阻塞直到另外一端打开为止。

    + **阻塞读打开FIFO成功：**说明已经有进程写打开了FIFO

        + 有写进程打开FIFO,且FIFO中没有数据，则读操作阻塞。写进程结束，读操作认为读到了文件结束符。

    + **非阻塞读打开FIFO：**无论是否有写进程打开了FIFO，都成功。

        + 有写进程打开FIFO,且FIFO中没有数据，读操作返回-1，当前errno值为EAGAIN，提醒以后再试。

        + 没有写进程打开FIFO,且FIFO中没有数据，

    + **阻塞写打开FIFO成功：**说明已经有进程读打开了FIFO

        + 当要写入的数据量不大于PIPE_BUF时，linux将保证写入的原子性。如果此时管道空闲缓冲区不足以容纳要写入的字节数，则进入睡眠，直到当缓冲区中能够容纳要写入的字节数时，才开始进行一次性写操作。

        + 当要写入的数据量大于PIPE_BUF时，linux将不再保证写入的原子性。FIFO缓冲区一有空闲区域，写进程就会试图向管道写入数据，写操作在写完所有请求写的数据后返回。

    + **非阻塞写打开FIFO：**

        + 当要写入的数据量大于PIPE_BUF时，linux将不再保证写入的原子性。FIFO有剩余空间时，在写满所有FIFO空闲缓冲区后，写操作返回；FIFO没有剩余空间,则失败返回`EAGAIN`。

        + 当要写入的数据量不大于PIPE_BUF时，linux将保证写入的原子性。

            + 如果当前FIFO空闲缓冲区能够容纳请求写入的字节数，写完后成功返回；

            + 如果当前FIFO空闲缓冲区不能够容纳请求写入的字节数，则返回EAGAIN错误，提醒以后再写；

5. 其他：

    + 写一个没有读打开的FIFO, 会产生`SIGPIPE`信号，读一个最后一个写进程关闭了的FIFO会产生一个文件结束符。

    + 读打开的阻塞标志只对本进程第一个读操作施加作用，如果本进程内有多个读操作序列，则在第一个读操作被唤醒并完成读操作后，其它将要执行的读操作将不再阻塞，即使在执行读操作时，FIFO中没有数据也一样（此时，读操作返回0）。


    + 造成阻塞的原因有两种：
    
        + 当前FIFO内有数据，但有其它进程在读这些数据；

        + FIFO有进程写打开，且FIFO内没有数据。(写打开进程结束则不再阻塞)

6. 实例；
    ```c
        //fifo_server.c
    #include <sys/stat.h>
    #include <sys/types.h>
    #include <fcntl.h>
    #include <errno.h>
    #include <unistd.h>
    #include <stdio.h>
    #include <string.h>
    #define BUF_MAX 8192
    #define fifo "./fifo"
    int main(){
        int fd, nrev,bytes_wr;
        char buf_wr[BUF_MAX];
        int flag = O_WRONLY;
    #ifdef NBLOCK
        flag |= O_NONBLOCK;
    #endif
    #ifdef ATOMIC
        bytes_wr = 2048;
    #else
        bytes_wr = 4096 + 1024;
    #endif
        memset(buf_wr, 42, BUF_MAX);
        if(mkfifo(fifo, 0666) < 0){
            perror("Create FIFO Error");
        }
        if((fd = open(fifo,flag)) < 0){
            perror("Open FIFO Failed");
        }
        if((nrev = write(fd, buf_wr,bytes_wr)) < 0){
            if(errno == EAGAIN){
                perror("Try Later");
            }
            perror("Write FIFO Error");
        }
        else
            printf("Write %d Bytes To FIFO\n", nrev);
        // pause();
        unlink(fifo);
        return 0;
    }
    //fifo_client.c
    #include <sys/stat.h>
    #include <sys/types.h>
    #include <fcntl.h>
    #include <errno.h>
    #include <stdio.h>
    #include <string.h>
    #include <stdio.h>
    #include <unistd.h>
    #define BUF_MAX 8192
    #define fifo "./fifo"
    int main(){
        int fd, nrev,bytes_rd;
        char buf_rd[BUF_MAX];
        int flag = O_RDONLY;
    #ifdef NBLOCK
        flag |= O_NONBLOCK;
    #endif
    #ifdef ATOMIC
        bytes_rd = 1000;
    #else
        bytes_rd = 4096 + 1024;
    #endif
        if((fd = open(fifo,flag)) < 0){
            perror("Open FIFO Failed");
        }
        while(1){
            memset(buf_rd, 0, sizeof(buf_rd));
            if((nrev = read(fd, buf_rd,bytes_rd)) < 0){
                if(errno == EAGAIN){
                    perror("NO DATA IN FIFO");
                }
                perror("Read FIFO Error");
            }
            else{
                printf("Read %d Bytes From FIFO: \n", nrev);
                printf("\t%s\n",buf_rd);
            }
            sleep(1);
        }
        return 0;
    }
    ```

## XSI IPC ##

1. XSI IPC 的三种IPC：消息队列，信号量，共享存储器。具体的实例成为IPC结构。

2. 每个IPC结构在内核里面都用一个非负长整型数的标识符表示，为了在外部能够使用IPC结构，使用一个键来和标识符相关联。键的类型是长整型，在`#include <sys/types.h>`中定义为`key_t`。

3. key值选择方式，有三种：

    + 指定key为大于0的常数，这需要用户自行保证生成的IPC key值不与系统中存在的冲突。

    + 指定key为IPC_PRIVATE，内核保证创建一个新的、唯一的IPC对象，IPC标识符与内存中的标识符不会冲突。IPC_PRIVATE为宏定义，其值等于0。

    + 调用ftok，给它传递pathname和id，操作系统根据两者合成key值。

4. 键的生成：
    ```C
        #include <sys/types.h>
        #include <sys/ipc.h>
        key_t ftok(const char *pathname, int proj_id);
    ```
    + 功能：根据参数生成一个键。

        + 两个参数都相同，生成的键相同；

        + 同一个文件，可以生成256个不同的键，取决于id的取值范围。

    + 参数：

        + `pathname`：指定的文件，改文件必须存在，而且可以访问。

        + `proj_id`：项目id，实际上只用了低八位，因此取值为1--255，不能为0。

    + 返回值：

        + 成功：返回键；

        + 失败：返回-1，错误记录在errno。

    + 键生成的过程：`ftok`实际上是访问了文件的`stat`结构分别获取其中的`st_dev`，`st_ino`，按照顺序：`id`的低八位-`st_dev`的低八位-`st_ino`的低16位,组合成为的一个32位键。

5. 通过键创建IPC结构，获取IPC标识符使用`msgget,semget,shmget`等函数。最后在使用相应函数做操作。

6. IPC结构的权限结构，每一个IPC结构都包含一个权限结构：
    ```C
        struct ipc_perm{
            key_t   __key ;          /* 此IPC对象的key键 */
            uid_t   uid ;          /* 所有者有效用户ID */
            gid_t   gid ;          /* 所有者有效组ID */
            uid_t   cuid ;         /* 创建者有效用户ID */
            gid_t   cgid ;         /* 创建者有效组ID */
            mode_t   mode ;        /* 此IPC的读写权限 */
            ulong_t  __seq ;         /* IPC对象的序列号 */
        }
    ```
    + 可以使用`msgctl,semctl,shmctl`来修改`uid,gid,mode`字段，但是调用进程必须是IPC结构的创建者或者是超级用户。

7. XSI IPC的问题：

    + IPC结构在文件系统中没有名字。访问和修改权限不能使用文件的函数，都有一套自己的函数。

    + IPC结构在系统范围内作用，没有引用计数。

    + 进程终止，IPC并不会自动消失(管道会)，除非一下三种情况：

        + 某个进程调用函数来读或者删除IPC结构；

        + 执行`ipcrm`删除；

        + 正在自举的系统删除；

8. 服务进程和客户进程使用同一IPC结构的方法：

    + 服务进程指定键`IPC_PRIVATE`创建IPC结构(使用`***get`函数)，存在一个指定的地方(文件)，客户进程来读。

    + 在公用头文件里面定义键。

    + 使用`ftok()`,使用同样的参数来确定同样的键。

## **消息队列** ##

1. 消息队列就是一个消息的链表，存储在内核里面。可以把消息看作一个记录，具有特定的格式以及特定的优先级。对消息队列有写权限的进程可以向中按照一定的规则添加新消息；对消息队列有读权限的进程则可以从消息队列中读走消息。消息队列是随内核持续的

2. 每个消息队列都有一个`struct msqid_ds`,定义在`<sys/msg.h>`
    ```C
        struct maqid_ds{
            struct ipc_perm msg_perm  ;  /* ownership and permission */
            time_t msg_stime          ;  /* time of last msgsnd()    */
            time_t msg_rtime          ;  /* time of last msgrcv()    */
            time_t msg_ctime          ;  /* time of last change      */
            undigned long __msg_cbytes;  /* current number of bytes in queue */
            msgqnum_t msg_qnum        ;  /*current number of messages */
            msglen_t msg_qbytes       ;  /*maxinum number of bytes allowed in 
                                        queue*/
            pid_t msg_lspid           ;  /* PID of last msgsnd() */
            pid_t msg_lrpid           ;  /* PID of last msgrcv() */
        }
    ```

2. 打开或者创建一个新消息队列:
    ```C
        #include <sys/types.h>
        #incldeu <sys/ipc.h>
        #include <sys/msg.h>
        int msgget(key_t key, int msgflg);
    ```
    + 功能：打开或者创建一个新消息队列

        + 创建消息队列的时候，初始化结构体`struct msqid_ds`:

            + `msg_perm`：结构中的`mode`按照`msgflg`中的相应位设置权限。
            
            + `msg_stime  msg_rtime msg_lrpid  msg_lspid   msg_qnum` 初始化为0.
                     
            + `msg_ctime` 初始化为现在的时间；        
            
            + `msg_qbytes`初始化为MSGMNB;      
                        
    + 参数：

        + `key`：

            + `IPC_PRIVATE`：创建一个新的消息队列，

            + 给的`key`没有与消息序列关联，且`msgflg`设置为`IPC_CREAT`则新建一个消息队列。

        + `msgflg`：八进制的消息队列操作权和控制命令的**或**

            + 操作权：所有者，组群，其他 的读、写权(没有执行权)，用吧进制数表示

            + 控制命令：

                + 如果指定了`IPC_CREAT|IPC_EXCL`，键已经与消息队列关联则失败，返回错误`EEXIST`在errno。

    + 返回值：

        + 成功： 返回消息队列ID

        + 失败：返回-1

3. 用于消息队列的控制
    ```C
    #include <sys/types.h> 
    #include <sys/ipc.h> 
    #include <sys/msg.h> 
    int   msgctl(int msqid,int cmd, struct msqid_ds *buf);
    ```
    + 功能：用于消息队列的控制:    
                        
    + 参数：

        + `msqid`：消息队列描述符，由 msgget 函数调用创建

        + `cmd`：指出将要采取的动作：

            + IPC_STAT：查看消息队列的状态,将msqid_ds结构中的数据存储到`buf`中。

            + IPC_SET：设置消息队列的状态,`msg_perm.uid, msg_perm.gid, msg_perm.mode, msg_perm.qbytes`这只为`buf`中指的值。

                + 只有进程的有效用户ID为`msg_perm.cuid或者msg_perm.uid`或者是超级用户再能设置。

                + 只有超级用户才能设置`msg_perm.qbytes`

            + IPC_RMID: 删除消息队列以及里面的数据，立即生效。其他进程下一次对消息队列进行操作返回错误`ERMID`。

                + 只有进程的有效用户ID为`msg_perm.cuid或者msg_perm.uid`或者是超级用户才能删除。

            + IPC_INFO MSG_INFO MSG_STAT
    + 返回值：

        + 成功： 返回0

        + 失败：返回-1     

4. 将新消息添加到队列尾:    
    ```C
    #include <sys/types.h> 
    #include <sys/ipc.h> 
    #include <sys/msg.h> 
    int msgsnd(int msqid,const void *msg_ptr,size_t msg_sz,int msgflg);
    ```

    + 功能：将新消息添加到队列尾。

    + 参数：

        + `msg_ptr`：指向`struct msgbuf`的指针
            ```c
                struct msgbuf{
                    long mtype; //消息的类型，必须是正数
                    char mtext[msg_sz];  //消息的内容，长度可以为0，
                }
            ```
        + `msg_sz`：消息内容的长度；

        + `msgflg`：可以设置为`IPC_NOWAIT`

            + 默认情况下没有设置，则当空间不够的时候，`msgsnd()`会阻塞，直到：

                + 有足够的空间；

                + 从系统中删除了此队列，此时返回`ERMID`

                + 捕获到一个信号，并且从信号中返回，此时返回`EINTR`

            + 设置了这个标志位，则失败，返回错误`EAGAIN`

    + 返回值：

        + 成功：返回0

        + 失败：返回-1    

5. 从队列中取出消息
    ```c
        #include <sys/types.h> 
        #include <sys/ipc.h> 
        #include <sys/msg.h> 
        size_t msgrcv(int msqid,void *msg_ptr,size_t msg_sz,long int msgtype,int msgflg);    
        ```
    + 功能：从队列中取出消息，放到msg_ptr指向的结构中。

    + 参数：

        + `msg_ptr`：指向`struct msgbuf`的指针
            ```c
                struct msgbuf{
                    long mtype; //消息的类型，必须是正数
                    char mtext[msg_sz];  //消息的内容，长度可以为0，
                }
            ```
        + `msg_sz`：指定消息内容的最大字节

            + 如果消息内容`mtext`长度大于`msg_sz`那么取决于`msgflg`中是否设置为`MSG_NOERROR`

        + `msgtype`：指定区消息的模式：

            + `msgtype == 0`：返回队列中的第一个消息；

            + `msgtype > 0`：返回队列中类型为`msgtype`的第一个消息；

            + `msgtype < 0`：返回队列中类型值小于等于`msgtype`绝对值的消息，如果有多个则返回类型值最小的一个。

        + `msgflg`：由一下的0个或多个相或

            + `IPC_NOWAIT:`设置了这个标志位，则此时返回-1，错误为`ENOMSG`

                + 没有设置，则当空间不够的时候，`msgrcv()`会阻塞，直到：

                    + 有这个类型的消息

                    + 从系统中删除了此队列，此时返回-1，错误为`ERMID`

                    + 捕获到一个信号，并且从信号中返回，此时此时返回-1，错误为`EINTR`

            + `MSG_NOERROR`：如果消息长度大于`msg_sz`，设置之后，则截断消息，没有设置则返回-1，错误为`E2BIG`

            + `MSG_EXCEPT`：当`msgtype > 0`的时候从队列里面读第一个不是`msgtype`的消息。

    + 返回值：

        + 成功：返回接收到`mtext`里面的字节数

        + 失败：返回-1    

6. 消息队列的实例：

### 信号量 ###

1. 信号量是一个特殊的计数器，用于多个进程之间共享资源的访问。只能对其进行等待和发送信号两种操作。

    + P（信号量变量sv）：等待。如果sv大于0，减小sv。如果sv为0，挂起这个进程的执行。

    + V（信号量变量sv）：发送信号。如果有进程被挂起等待sv，使其恢复执行。如果没有进行被挂起等待sv，增加sv。

2. 操作函数：
    ```C
    #include <sys/sem.h>
    int semget(key_t key, int nsems, int semflg);
    ```

    + 功能：创建或一引用一个信号量，实际上是创建了一个信号量集合，并且制定了其中信号量的个数。
        
        + 内核为每个信号量集合号维护一个`struct semid_ds`的结构体，在调用`semget`的时候会初始化这个结构体，其中`sem_nsems`被设置为`nsems`的值，其他成员设为相应的值。
        ```C
        struct semid_ds{
            struct ipc_perm sem_perm; /*permission and */
            unsigned short sem_nsems; /*number of semaphores in set */
            time_t sem_otime;  /* last-semop() time */
            time_t sem_ctime;  /* last-change time */
            ...
        }
        ```
        + 每个信号量和一个匿名结构关联，但是`semget`并不初始化这个结构，由`senctl`来初始化。
        ```C
        struct {
            unsigned short semval;  /* semaphore value, always >=0 */
            pid_t sempid;           /* pid for last operation */
            unsigned short semncnt; /* processes awaiting semval > curval*/
            unsigned short semzcnt; /* prodesses awaiting semval == 0 */
        }
        ```

    + 参数：

        + `key`和消息队列的一样

        + `nsems`：指定需要的信号量的数目，它的值几乎总是1.

            + (服务进程)创建集合的时候，需要指定`nsems > 0`，(客户进程)引用集合的时候，`nsems = 0`;

        + `semflg`和消息队列一样

    + 返回值：

        + 成功：返回信号量ID

        + 失败：返回-1；

3. 信号量控制函数：
    ```C
    #include <sys/sem.h>
    int semctl(int semid, int semnum, int cmd,...);
    ``` 
    + 功能：

    + 参数：

        + `semnum`：

        + 第四个参数：可选，由一个联合指定：
        ```C
        union semun{
            int val;
            struct semid_ds *buf;
            unsigned short *array;
        } arg;
        ```

        + `cmd`：

            + IPC_STAT  对此集合获取`semid_ds`结构，并且存在arg.buf中

            + IPC_RMID  从系统中删除信号量集合，和消息队列一样。

            + IPC_SET   按照`arg.buf`中的值；来设置部分值，和消息队列一样。

            + GETALL    返回所有信号量的值，结果保存在arg.array中，参数sennum被忽略；

            + GETNCNT   返回等待semnum所代表信号量的`semncnt`的值；

            + GETPID    返回最后一个对semnum所代表信号量执行semop操作的进程ID`sempid`；

            + GETVAL    返回semnum所代表信号量的值`semval`；

            + GETZCNT   返回等待semnum所代表信号灯的值变成0的进程数`semzcnt`；

            + SETALL    通过arg.array更新所有信号灯的值；同时，更新与本信号集相关的semid_ds结构的sem_ctime成员；

            + SETVAL    设置semnum所代表信号灯的值为arg.val；

    + 返回值：

        + 成功：

            + 除了`GETALL`之外的所有GET命令返回获取的值，其他的返回0

        + 失败：返回-1，设置`errno`

4. 信号量操作函数：
    ```C
    #include <sys/sem.h>    
    int semop(int semid, struct sembuf *sops, size_t nsops);
    ```

    + 功能：

    + 参数：

        + `struct sembuf *sops`：(semophare operation structure)
        ```C
        struct sembuf{
            short sem_num; //semaphore numbre
            short sem_op;  //semaphore operation
            short sem_flg; //operation flags
        }
        ```
            + 一般`sem_op`取 1(发送信号，释放资源)/-1(等待，获得资源)

            + 具体参看apue，458页。

    + 返回值：成功返回0，否则返回-1，并设置`errno`


### 共享存储 ###


### 套接字 ###

#### TCP/IP 基础 ####

网络构成要素：

1. 网卡：连接互联网

2. 中继器：作为对网络中衰弱的信号进行放大和发送的设备，连接在物理层，以便传输给另一个电缆。并不能判断数据是否有错，也无法改变传输速度。

    + 一般用于同种介质之家你转接工作，有时候也可以用于电缆和光缆之间调整信号。

    + 有的中继器叫做集线器。

3. 网桥/2层交换机：用于连接一个网络与另外一个网络，属于OSI模型的第二层数据链路层(因此也叫做2层交换机)，根据数据帧的内容发送给相邻的其他网络。

    + 例如常用的交换机。(根据交换机连接的不同网络设备的物理地址，发送内容)

    + 根据物理地址(MAC地址)进行处理。

3. 路由器/3层交换机：在网络层上连接两个网络的设备，并对根据IP地址，分组报文进行转发的设备(即，将报文根据IP地址分类，转发给不同IP)。

    + 根据IP地址进行处理。

    + 可以连接不同的数据链路层。

4. 4-7层交换机：负责处理传输层到应用层的数据，负载均衡器，带宽控制，广域网加速器，防火墙。

5. 网关：将传输层到应用层的数据进行转换和转发的设备。进行协议的转换和数据的转发。同一类型协议之间数据转发的交租应用网关，


TCP/IP的分层模型：

1. 物理层(硬件)：负责传输数据的硬件

2. 数据链路层(网络接口层)：利用以太网中的数据链路进行通信。

    + 有时候，网络接口层和物理层成为网络通信层。

3. 网络层：使用IP协议，基于IP地址转发分包数据。

    + IP：IP地址以主机作为标识，是分组交换的一种协议，但是不具有重发机制，属于非可靠性传输协议。

    + ICMP：IP数据包在发送过程中一旦发生异常导致无法到达目的地址，需要给发送端发送一个异常通知，有时候也用来诊断网络的健康状况。

    + ARP：从分组数据包中解析出物理地址(MAC)的一种协议。

4. 传输层：传输层主要的功能是让应用程序之间实现通信。十分应用程序的是端口号。

    + TCP：一种面向有链接的传输协议，可以保证通信主机之间通信可达。可以正确处理丢包，乱序的情况，但是为了建立连接至少7次收包发包，浪费网络流量，不适合在视屏会议等场合使用。

    + UDP：一种面向无连接的传输协议。常用于数据量较少，或多播，广播通信。

    + **网络层和传输层通常由操作系统提供**

5. 应用层：对应于OSI模型中的会话层+表示层+应用层

    + WWW：浏览器于服务器之间的协议是HTTP(超文本传输协议)，主要的数据格式是HTML。HTTP属于OSI中的应用层协议，HTML属于OSI中的表示层协议。

    + 电子邮件(SMTP,Simple Mail Transfer Protocol)

    + 文本传输(FTP, File Transfer Protocol)：使用过程中会建立两个连接：发出传输请求要哦用到的控制连接，实际传输时用到的数据连接。

    + 远程登录(TELNET与SSH)：

    + 网络管理协议(SNMP,Simole Network Management Protocol)



#### 套接字接口 ####

1. 使用 socket 函数创建套接字
    ```C
    #include <sys/socket.h>
    int socket(int domain, int type, int protocol);
    ```
    + 功能：创建套接字

    + 参数：

        + `domain`：确定通信的特性，包括地址格式，每个域都有自己的地址格式。POSIX.1指定的域包括：

            + AF_INET ：IPv4地址域。

            + AF_INET6 ：IPv6地址域。

            + AF_UNIX ：UNIX域。

            + AF_UNSPEC ：未指定，可以代表任何域。

        + `type`：确定套接字的类型。POSIX.1定义的套接字类型有：

            + SOCK_SEQPACKET ：长度固定、有序、可靠的面向连接报文传递，默认协议SCTP(Stream Control Transfer Protocol)。从套接字接收的数据量和对方发送的一致。

            + SOCK_STREAM ：有序、可靠、双向的面向连接字节流，默认协议TCP。应用程序分不清字节流服务报文界限，从套接字读取数据时可能需要多次函数调用。

            + SOCK_DGRAM ：长度固定、不可靠的无连接报文传递，默认协议UDP。

            + SOCK_RAW ：IP协议的数据报接口，默认协议直接基于IP。套接字提供了一个数据报接口用于直接访问网络层（IP层），使用它时需要自己构造协议首部。创建 SOCK_RAW 套接字需要超级用户特权。

        + `protocol`：通常为0，表示按给定的域和套接字类型选择默认协议。在 domain 和 type 给定的情况下如果有多个协议，可以用 protocol 指定协议。因特网域套接字定义的协议：

            + IPPROTO_IP: Ipv4网际协议；

            + IPPROTO_IPV6：Ipv6网际协议；

            + IPPROTO_ICMP：因特网控制报文协议(Internet Control Message Protocol)；

            + PPROTO_RAW：原始IP数据包协议；

            + IPPROTO_TCP：传输控制协议；

            + IPPROTO_UDP：用户数据报协议；

    + 尽管套接字描述符是文件描述符，担不是所有使用文件描述符的函数都能处理套接字描述符，下面是有关函数的支持情况：

        + close   释放套接字

        + dup dup2    正常复制

        + fcntl   支持一些命令，如 F_DUPFD 、 F_GETFD 、 F_GETFL 、 F_GETOWN 、 F_SETFD 、 F_SETFL、 F_SETOWN

        + fstat   支持一些 stat 结构成员，由实现定义

        + ioctl   支持部分命令，依赖于底层设备驱动

        + poll    正常使用

        + read readv  等价于无标志位的 recv

        + select  正常使用

        + write writev    等价于无标志位的 send

    + 返回值：

        + 成功： 返回描述符

        + 失败：返回-1，设置errno。

2. 禁止套接字上的输入输出：
    ```C
    #include <sys/socket.h>
    int shutdown(int sockfd, int how);
    ```

    + 功能：

    + 参数：

        + `how`:

            + SHUT_RD ，关闭读端，即无法从套接字读取数据。

            + SHUT_WR ，关闭写端，即无法用套接字发送数据。

            + SHUT_RDWR ，关闭读写，同时无法读取和发送数据。

    + 返回值：

        + 成功： 返回0



        + 失败：返回-1，设置errno。

    + `close`：释放套接字，只有最后一个描述符关闭才会释放网络端点。

3. 网络间进程标识：计算机网络地址，计算机上用端口表示的服务。

4. 字节序：就是不同计算机是大端还是小端的问题，造成通信的问题。TCP/IP协议栈规定使用大端字节序通信。

    + 大端：低字节数据存储在高地址

    + 小端：低字节数据存储在低地址

5. 处理机字节序和网络字节序之间的转换：
    ```C
    #include <arpa/inet.h>
    /* 将主机字节序的32位整型数转换为网络字节序 */
    uint32_t htonl(uint32_t hostlong);
    /* 将主机字节序的16位整型数转换为网络字节序 */
    uint16_t htons(uint16_t hostshort);
    /* 将网络字节序的32位整型数转换为主机字节序 */
    uint32_t ntohl(uint32_t netlong);
    /* 将网络字节序的16位整型数转换为主机字节序 */
    uint16_t ntohs(uint16_t netshort);
    ``` 

6. 地址格式：地址标识特定通信域中的套接字端点，地址格式和特定通信域相关。为兼容不同格式的地址，地址被强制转换为通用的地址结构 sockaddr ，Linux系统中该结构定义如下：
    ```C
    #include <netinet/in.h>
    struct sockaddr {
        sa_family_t sa_family;      /* 地址类型 */
        char        sa_data[14];    /* 变长地址 */
    };
    ```
    + in_port_t 定义为 uint16_t ， in_addr_t 定义为 uint32_t 。
    + AF_INET 域中，套接字地址结构如下:
    ```C
    struct in_addr {
        in_addr_t       s_addr;         /* IPv4地址32位 */
    };
    struct sockaddr_in {
        sa_family_t     sin_family;     /* 地址类型 */
        in_port_t       sin_port;       /* 端口号 */
        struct in_addr  sin_addr;       /* IPv4地址 */
        unsigned char   sin_zero[8];    /* 0填充 */
    };    
    ```

    + AF_INET6 域中，套接字地址结构如下：
    ```C
    struct in6_addr {
    uint8_t         s6_addr[16];    /* IPv6地址128位 */
    };
    struct sockaddr_in6 {
        sa_family_t     sin6_family;    /* 地址类型 */
        in_port_t       sin6_port;      /* 端口号 */
        uint32_t        sin6_flowinfo;  /* 传输类和流信息 */
        struct in6_addr sin6_addr;      /* IPv6地址 */
        uint32_t        sin6_scope_id;  /* 作用域的接口集 */
    };
    ```

7. 地址二进制和十进制的转换：可以用 inet_ntop 和 inet_pton 函数对IPv4和IPv6地址作二进制和点分十进制字符串之间的转换。类似的还有 inet_addr 和 inet_ntoa 等函数，但它们只能用于IPv4地址。

    + 二进制地址-->字符串
    ```C
    #include <arpa/inet.h>
    const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);
    ```
        + 功能：将af域中的网络字节序的二进制地址转换成为字符串，存在dst指向的缓冲区

        +　参数：

            + `af`：只支持`AF_INET`和`AF_INET6`；

            + `size`：指定dst的缓冲区的大小，可用 INET_ADDRSTRLEN 和 INET6_ADDRSTRLEN 来为IPv4和IPv6地址的字符串设置足够大的空间。

        + 返回值：

            + 成功：返回指向dst的指针；

            + 失败：返回空指针，设置errno；

    + 字符串-->二进制地址
    ```C
    #include <arpa/inet.h>
    int inet_pton(int af, const char *src, void *dst);
    ```
        + 功能：将af域中的字符串地址转换成为网络字节序的二进制地址，存在dst指向的缓冲区

        +　参数：

            + `af`：只支持`AF_INET`和`AF_INET6`；

        + 返回值：

            + 成功：返回1；

            + 失败：返回0，则表示src中的字符串不是有效的网络地址；返回-1，则表示af不是有效的address family，并设置errno；

8. 地址查询：找到给定计算机的主机信息：

    + 涉及的文件：`/etc/hosts` host 数据文件

    + 获取主机结构体信息
    ```C
    #include <netdb.h>
    extern int h_errno;
    struct hostent *gethostent(void);/*system V / POSIX 扩展*/
    ```
        + 功能：获取主机结构体信息

        + 结构体：
        ```C
        struct hostent {
            char  *h_name;            /* 主机名 */
            char **h_aliases;         /* 主机别名列表 */
            int    h_addrtype;        /* 主机地址类型 */
            int    h_length;          /* 地址长度 */
            char **h_addr_list;       /* 地址列表 */
        };
        ```

        + 返回值：  

            + 成功返回结构体指针；    

            + 失败返回空指针，错误编号存在`h_errno`；

    + 打开数据库文件
    ```C
    #include <netdb.h>
    extern int h_errno;
    void sethostent(int stayopen);
    ```
        + 功能：   

        + `stayopen`：   

            + 0：    

            + 非0值：在调用`gethostent`之前文件保持打开。

    + 关闭文件
    ```C
    #include <netdb.h>
    extern int h_errno;
    void endhostent(void);
    ```

9. 获得网络名字和网络编号：读的数据库文件是 `/etc/networks`

    + 遍历网络信息
    ```C
    #include <netdb.h>
    struct netent * getnetent(void);
    ```
        + 功能：从网络数据库文件下一个网络入口开始遍历网络信息，并返回；   

        + 网络号按网络字节序返回。地址类型为 AF_XX 的地址族常量。   

        + 结构体：
        ```C
        struct netent{
            char      *n_name;     /* 网络名 */
            char     **n_aliases;  /* 网络别名列表 */
            int        n_addrtype; /* 网络地址类型，通常是AF_INET */
            uint32_t   n_net;      /* 主机字节序的网络号 */
        };
        ```
        + 返回值：  

            + 成功：返回结构体指针；   

            + 失败或者到达文件尾： 返回空指针，并且设置errno。

    + 从数据库文件获取特定网络名信息
    ```C
    #include <netdb.h>
    struct netent * getnetbyname(const char* name);
    ```
        + 功能：从数据库文件获取特定网络名信息，并返回。
        
        + 网络号按网络字节序返回。地址类型为 AF_XX 的地址族常量。   

        + 返回值：  

            + 成功：返回结构体指针；   

            + 失败或者到达文件尾： 返回空指针，并且设置errno。

    + 从数据库文件获取特定网络地址的信息
         ```C
        #include <netdb.h>
        struct netent * getnetbyaddr(uint32_t net, int type);
        ```
        + 功能：从数据库文件获取特定网络地址的信息，并返回。
        
        + net参数必须是按照主机的字节序。 

        + 返回值：  

            + 成功：返回结构体指针；   

            + 失败或者到达文件尾： 返回空指针，并且设置errno。

    + 打开与数据库的连接：
     ```C
    #include <netdb.h>
    void setnetent(int stayopen);
    void endnetent(void);
    ```
        + 功能：   

            + `setnetent`打开与数据库的连接，并且设置下一个入口为第一个入口。如果`stayopen`是非0的话，在调用`getnet*`函数之前，与数据库的连接不会关闭。  

            + `endnetent`关闭与数据库的连接。

10. 获取协议名字和协议号： 协议数据库文件 `/etc/protocols`

    + 遍历数据库文件获取协议信息：
    ```C
    #include <netdb.h>
    struct protoent *getprotoent(void);
    ```
        + 功能：从数据库文件中读下一个入口，并且返回结构体  

        + 结构体：
        ```C
        struct protoent {
            char  *p_name;       /* 协议名 */
            char **p_aliases;    /* 协议别名列表 */
            int    p_proto;      /* 协议号 */
        };
        ```
        + 返回值：  

            + 成功返回结构体指针；    

            + 失败或者读到文件尾，返回空指针，错误编号存在`errno`；

    + 从数据库文件按照协议名读取结构体并返回。
    ```C
    #include <netdb.h>
    struct protoent *getprotobyname(const char *name);
    ```
        + 功能：从数据库文件按照协议名读取结构体并返回。   

        + 返回值：  

            + 成功返回结构体指针；    

            + 失败或者读到文件尾，返回空指针，错误编号存在`errno`；
        ```C
        #include <netdb.h>
        struct protoent *getprotobynumber(int proto);
        ```
        + 功能：从数据库文件按照协议号读取结构体并返回。   

        + 返回值：  

            + 成功返回结构体指针；    

            + 失败或者读到文件尾，返回空指针，错误编号存在`errno`；

    + 打开与数据库的连接
    ```C
    #include <neydb.h>
    void setnetent(int stayopen);
    void endnetent(void);
    ```
        + 功能：   

            + `setprotoent`打开与数据库的连接，并且设置下一个入口为第一个入口。如果`stayopen`是非0的话，在调用`getnet*`函数之前，与数据库的连接不会关闭。    

            + `endprotoent`关闭与数据库的连接。

11. 读取服务与端口： 服务数据库文件：`/etc/services`

    + 数据库文件中记录格式为： 服务名  端口号/协议，实际上建立了服务与端口的对应关系，在这个文件中的服务名和端口号在编程中可以互换使用，用户也可以自己添加自己定义的服务名与端口号。

    + 遍历服务与端口号的对应关系
    ```C
    #include <netdb.h>
    struct servent *getservent(void);
    ```
        + 功能：按照顺序从数据库文件中读下一个入口，并且返回结构体  

        + 结构体：
        ```C
        struct servent {
            char  *s_name;       /* 服务名 */
            char **s_aliases;    /* 服务别名列表 */
            int    s_port;       /* 端口号 */
            char  *s_proto;      /* 使用的协议 */
        };
        ```
        + 返回值：  

            + 成功返回结构体指针；    

            + 失败或者读到文件尾，返回空指针，错误编号存在`errno`；

    + 获取指定服务名和协议类型的端口号：
    ```C
    #include <netdb.h>
    struct servent *getservbyname(const char *name, const char *proto);
    ```
        + 功能：从数据库文件按照服务名和协议读取结构体并返回。    

        + 返回值：  

            + 成功返回结构体指针；    

            + 失败或者读到文件尾，返回空指针，错误编号存在`errno`；

    + 获取指定端口与协议的服务名：
    ```C
    #include <netdb.h>
    struct servent *getservbyport(int port, const char *proto);
    ```
        + 功能：从数据库文件按照端口号和协议读取结构体并返回。    

        + 返回值：  

            + 成功返回结构体指针；    

            + 失败或者读到文件尾，返回空指针，错误编号存在`errno`；

    + 打开/关闭数据库文件：
    ```C
    #include <neydb.h>
    void setservnet(int stayopen);
    void endservnet(void);
    ```
        + 功能：   

            + `setservnet`打开与数据库的连接，并且设置下一个入口为第一个入口。如果`stayopen`是非0的话，在调用`getnet*`函数之前，与数据库的连接不会关闭。 

            + `endservnet`关闭与数据库的连接。

12. 将主机名(IP地址)和服务名(端口)映射到一个`struct sockaddr`地址结构

    + 指定IP和端口号到地址结构里面：
    ```C
    #include <sys/types.h>
    #include <sys/socket.h>
    #include <netdb.h>
    int getaddrinfo(const char *node, const char *service,const struct addrinfo *hints, struct addrinfo **res);
    ```
        + 功能：给定主机名(IP地址)、服务名(端口号)，返回一个或者多个`struct addrinfo`结构体，到res中。主要是得到一个`struct sockaddr`的地址。   

            + 主机名可以是主机名字或者点分格式的主机地址。可以同时提供主机名和服务名，或者只提供其中一者，那么另外一个就是空指针。    

            + 如果是服务端，可以只指定端口号，不指定IP地址，但是`ai_flags`要设置成`AI_PASSIVE`，此时服务端地址是0.0.0.0; 


        + `addrinfo`结构体：链表结构
        ```C
        struct addrinfo{
            int              ai_flags;   /* 表示如何处理地址和名字，多个可以相或 */
            int              ai_family;  /* 地址类型(域)，0表示任意类型都可以 */
            int              ai_socktype;/* 套接字类型，0表示任意类型都可以 */
            int              ai_protocol;/* 协议(号)，0表示任意协议都可以 */
            socklen_t        ai_addrlen; /* 地址长度 */
            struct sockaddr *ai_addr;    /* 套接字地址 */
            char            *ai_canonname;/* 主机规范名 */
            struct addrinfo *ai_next;    /* 链表下一个指针 */
        };
        ```
            + `ai_flags`：   

                + AI_ADDRCONFIG ：查询配置的地址类型（IPv4或IPv6）。  

                + AI_ALL ：查找IPv4和IPv6地址，仅用于 AI_V4MAPPED 。   

                + AI_CANONNAME ：需要一个规范名而不是别名。   

                + AI_NUMERICHOST ：以数字格式返回主机地址。  

                + AI_NUMERICSERV ：以端口号返回服务。 

                + AI_PASSIVE ：套接字地址用于监听绑定。  

                + AI_V4MAPPED ：如果没找到IPv6地址，返回映射到IPv6格式的IPv4地址。  

        + 参数：   

            +  `node`：主机名，可以是一个名字，也可以是点格式的字符串地址。当使用名字的时候，这个名字必须在`/etc/hosts`文件里面有对应的地址，如下面`hosts`的内容，使用127.0.1.1 和使用Ubuntu14是一样的。实际上就是制定地址。
            ```C
            127.0.0.1 localhost
            127.0.1.1 Ubuntu14
            # The following lines are desirable for IPv6 capable hosts
            ::1     ip6-localhost ip6-loopback
            fe00::0 ip6-localnet
            ff00::0 ip6-mcastprefix
            ff02::1 ip6-allnodes
            ff02::2 ip6-allrouters
            ff02::3 ip6-allhosts
            ``` 

            + `service`：指定的服务，实际上就是端口。在文件`/etc/services`里面记录了服务名，端口号以及其协议的对应关系。 

                + 如果要指定服务名，则可以在`services`文件里面添加需要的服务名，端口号，协议。   

                + 也可以直接写字符串的端口号。    

            + `hints`：用来筛选符合特定条件的地址，hints是一个用来过滤的模板，除了`ai_family, ai_flags, ai_protocol, ai_socktype`可以设定之外其他的都设置为0或者空指针。   

        + 返回值：  

            + 成功返回0     

            + 失败返回非0错误码。

    + 释放`addrinfo`结构：
    ```C
    #include <sys/types.h>
    #include <sys/socket.h>
    #include <netdb.h>   
    void freeaddrinfo(struct addrinfo *res);
    const char *gai_strerror(int error); 
    ```
        + `freeaddrinfo`：释放`addrinfo`结构；

        + `gai_strerror`：将`getaddrinfo`的错误码转换成为错误消息。

    + 将套接字地址`struct sockaddr`转换成为一个主机名和一个服务名
    ```C
    #include <sys/socket.h>
    #include <netdb.h>
    int getnameinfo(const struct sockaddr *sa, socklen_t salen, char *host, size_t hostlen, char* serv, size_t servlen, int flags);
    ```
        + 功能：将套接字地址转换成为一个主机名和一个服务名。 

        + 参数：   

            + `flags`指定一些转换的方式：     

                + NI_DGRAM ：服务基于数据报(UDP)而非基于流(TCP)。 

                + NI_NAMEREQD ：如果找不到主机名，将其视作错误。 

                + NI_NOFQDN ：对于本地主机，仅返回完全限定域名的节点名部分。    

                + NI_NUMERICHOST ：以数字形式返回主机地址。  

                + NI_NUMERICSERV ：以端口号返回服务地址。   

        + 返回值：  

            + 成功返回0 

            + 失败返回非0错误码。

13. 套接字与地址：

    + 绑定地址：
    ```C
    #include <sys/socket.h>
    int bind(int sockfd, const struct sockaddr *addr, socklen_t len);
    ```
        + 功能：给本地没有分配套接字地址的套接字分配一个本地套接字地址。

        + 参数：

        + `sockfd`：套接字描述符，由`socket( )`创建，仅仅确定了域和套接字类型，以及协议。

        + `addr`：套接字地址指针，指向结构体`struct sockaddr`，长度个格式取决于所使用的addres  s family。对于地址，要求：

                + 地址必须有效，不能指定其他机器的地 址。

                + 地址必须和套接字的地址族所支持的格式匹配。

                + 如果不是超级用户，端口号不能小于1024。

                + 一般只一个套接字端点能够和一个地址绑定，也有协议允许多重绑 定。

        + `len`：地址长度

        + 返回值：

            + 成功： 返回0；

            + 失败： 返回-1，设置errno；

    + 对于因特网域，如果指定IP地址为 INADDR_ANY(`<netinnet/in.h>`) ，套接字端点可以被绑定到所有的系统网络接口，这样它可以收到这个系统的所有网卡的数据包。

    + 通过套接字描述符得到与套接字绑定的地址
    ```C
    #include <sys/socket.h>
    int getsockname(int socket, struct socksddr *restrict address, socklen_t *restrict address_len);
    ```
        + 功能：通过套接字描述符得到与套接字绑定的地址；   

        + 参数：   

            + `socket`：如果该套接字没有绑定地址，结果是未定义的。    

            + `address`：存储套接字地址的指针； 

            + `sddress_len`：用户指定的套接字地址结构体大小，如果指定大小比实际的地址长度小，则会发生截断，但是不会报错。  

        + 返回值：  

            + 成功： 返回0；  

            + 失败： 返回-1，设置errno；

    + 获取对方的套接字
    ```C
    #include <sys/socket.h>
    int getpeername(int socket, struct socksddr *restrict address, socklen_t *restrict address_len);
    ```
        + 功能：通过与本进程连接的套接字描述符(对等方套接字描述符)得到与套接字绑定的地址； 

        + 参数：   

            + `socket`：如果该套接字没有绑定地址，结果是未定义的。    

            + `address`：存储套接字地址的指针； 

            + `sddress_len`：用户指定的套接字地址结构体大小，如果指定大小比实际的地址长度小，则会发生截断，但是不会报错。  

        + 返回值：  

            + 成功： 返回0；  

            + 失败： 返回-1，设置errno；

14. 建立连接：主要针对面向连接的传输协议，如(`SOCK_STREAM和SOCK_SEQPACKET`)

    + 面向连接的传输协议，在交换数据之前需要建立连接(如TCP)；
    ```C
    #include <sys/socket.h>
    int connect(int socket, const struct sockaddr *address, socklen_t address_len);
    ```
        + 功能：有客户端发起连接请求，并尝试把本地套接字与服务器的地址建立连接。   

        + 参数：   

            + `socket`：客户端套接字；  

                + 如果套接字没有和一个地址绑定，`connect`会给绑定一个本地未用的地址 

                + 如果套接字是面向连接的，`connect`会尝试建立一个连接。如果连接不能立即建立：    

                    + `socket`没有设置了`O_NONBLOCK`，`connect`会阻塞一个不确定的时长，直到连接建立。如果超过了这个时间，连接失败，并且连接会被中断，不在连接。如果阻塞的时候连接被一个信号中断，连接失败，设置错误为`EINTR`，但是连接不会被中断，连接会异步的被建立。    

                    + `socket`设置了`O_NONBLOCK`，但是连接没有立即建立，则`connect`返回失败，错误为`EINPROGRESS`，但是连接不会被终止，连接会异步建立，直到建立成功之前，没有建立成功返回错误类型为`EALREADY`。可以使用`select`和`poll`来判断何时可写，可写，则连接成功。    

                + 如果套接字不是面向连接的，`connect`会设置对方的地址为`address`，仅能接收该地址的报文，并且不建立连接。  

            + `address`：服务器套接字地址；   

            + `address_len`：服务器套接字地址长度； 

        + 返回值：  

            + 成功： 返回0；  

            + 失败： 返回-1，设置errno；

15. 监听：
    ```C
    #include <sys/socket.h>
    int listen(int socket, int backlog);
    ```
    + 功能：用来标记面向连接的套接字，表示套接字可以接受`backlog`个连接请求；

    + 参数：

        + `backlog`：用来限制套接字接收连接请求的队列大小。

            + 最大值在文件`sys/socket.h`中定义为`SOMAXCONN`。

            + 若果设置的值超过最大值，则设置成最大值；

            + 如果设置成0，则设置成为具体unix实现设置的最小值。

            + 如果比0小，则与设置为0一样；

    + 返回值：

        + 成功： 返回0；

        + 失败： 返回-1，设置errno；

16. 接受：
    ```C
    #include <sys/socket.h>
    int accept(int socket, struct soxkaddr *restrict address, socklen_t *restrict sddress_len);
    ```
    + 功能：接受客户端的连接请求，并且把地址返回到`sddress`所指的空间(如果没有设置为NULL的话)。

        + 在还可以接受连接请求的时候，如果套接字设置为阻塞(没有设置`O_NONBLOCK`)，那么没有连接之前会一直阻塞。

        + 在还可以接受连接请求的时候，如果套接字设置为非阻塞(设置`O_NONBLOCK`)，那么`accept`会失败，并且设置错误为`EAGAIN`或者`EWOULDBLOCK`

        + 如果协议允许连接没有绑定地址的连接，而且客户端套接字没有绑定地址，则结果没有定义。

    + 参数： 

        + `socket`：服务器的套接字，必须已经绑定地址，而且已经成功调用`listen`

        + `address`：输出

            + 设置为空指针，表示对此参数不关心；

            + 一个指向套接字地址的指针，客户端地址会返回到指针所指的内存。

        + `address_len`：

            + 空指针，不关心地址；

            + 标志地址长度的指针，如果设定的长度比实际地址长度小，则会发生截断

    + 返回值：

        + 成功： 返回客户端套接字描述符；

        + 失败： 返回-1，设置errno；

17. 数据传输：

    + 发送数据：
    ```C
    #include <sys/socket.h>
    ssize_t send(int socket, const char *buffer, size_t length, int flags);
    ```
        + 功能：发送消息给客户端或者服务端。函数的成功调用并不代表消息已经成功发送给对方，而是代表数据已经成功发送到网络驱动程序上。失败也只表示本地的失败。 

            + 发送消息的长度由`length`指定，但是超过了特定的协议下规定的长度的时候，`send`会失败，并且数据不会被发送。   

            + 对于发送的套接字，没有足够的空间来存储发送的信息，且套接字是阻塞的(没有设置`O_NONBLOCK`)，`send`会一直阻塞，知道有足够空间。  

            + 对于发送的套接字，没有足够的空间来存储发送的信息，且套接字是非阻塞的(设置了`O_NONBLOCK`)，`send`失败。 

            + `select`和`poll`可以用来确定什么时候可以发送数据。  

        + 参数：   

            + `length`：表示发送信息的字节长度； 

            + `flags`：可以使用下面的多个或一个相 或   

                + MSG_DONTROUTE ：勿将数据路由出本地网络。   

                + MSG_DONTWAIT ：允许非阻塞操作，等价于用 O_NONBLOCK 。   

                + MSG_EOR ：如果协议支持，此为记录结束。   

                + MSG_OOB ：如果协议支持，发送带外数据。   

        + 返回值：  

            + 成功： 返回传输的字节数； 

            + 失败： 返回-1，设置errno；

    + 接受数据：
    ```C
    #include <sys/socket.h>
    ssize_t recv(int socket, void *buffer, size_t length, int flags);
    ```
        + 功能：接受数据存在缓冲区。 

            + 对于基于消息的套接字，如 `SOCK_DGRAM, SOCK_SEQPACKET`，消息会一次性读完。如果消息太长，超过了`length`指定的值，如果没有设定`MSG_PEEK`多余的会被丢弃。    

            + 对于基于流的套接字，如`SOCK_STREAM`，消息的边界会被忽略，一旦数据可用就会被返回，没有数据会被丢弃   

            + 对于发送的套接字，没有足够的空间来存储发送的信息，且套接字是阻塞的(没有设置`O_NONBLOCK`)，`recv`会一直阻塞，知道有足够空间。  

            + 对于发送的套接字，没有足够的空间来存储发送的信息，且套接字是非阻塞的(设置了`O_NONBLOCK`)，`recv`失败。 

        + 参数：   

            + `flags`：可以使用下面的多个或一个相 或   

                + MSG_PEEK：返回数据包内容但是不真正取走数据包；   

                + MSG_DONTWAIT：recvmsg 处于非阻塞模式，相当于`O_NONBLOCK`； 

                + MSG_TRUNC：即使数据包被截断也返回数据包实际长度。 

                + MSG_OOB ：接收到带外数据； 

                + MSG_WAITALL：对于流套接字(`SOCK_STREAM`)，函数阻塞到所有数据都返回，
        + 返回值：  

            + 成功： 返回传输的字节数； 

            + 失败： 返回-1，设置errno；

    + 发送数据：
    ```C
    #include <sys/socket.h>
    ssize_t sendto(int socket, const void *message, size_t length, int flags, const struct sockaddr *dest_addr, socklen_t dest_len);
    ```
        + 功能：与`send`一样除了一下几点：   

            + 对于面对链接的套接字，地址和地址长度被忽略，因为连接中隐含了目标地址。   

            + `sendto`的参数里面有地址和地址长度，因此当套接字是不是面向连接的时候，将直接向地址发送数据报，这个地址必须由`connect`设置过。   

            + 如果套接字协议支持广播，而且地址是一个广播地址，套接字也设置了`O_BROADCAST`则可以向广播地址广播。

    + 接受数据：
    ```C
    #include <sys/socket.h>
    ssize_t recvfrom(int socket, const void *message, size_t length, int flags, const struct sockaddr *dest_addr, socklen_t dest_len);
    ```
        + 和`send`对应，`flags`和`recv`一样。

    + 发送接受数据：
    ```C
    #include <sys/socket.h>
    ssize_t sendmsg(int socket, const struct msghdr *message, int flags);
    ssize_t recvmsg(int socket, const struct msghdr *message, int flags);
    ```
        + 功能：如果是面向连接的套接字，结构体里面的地址将会被忽略，否则，会想结构体里面的地址发送消息。其余与以上的`sendto`一样。

    + 参数：

            + `mseeage`：结构体指针；
            ```C
            struct msghdr{
                void *msg_name;          /* 地址，不是面向链接的套接字时用 */
                socklen_t msg_namelen;   /* 地址长度 */
                struct iovec *msg_iov;   /* I/O缓冲数组，高级I/O writev/readv */
                int msg_iovlen;          /* I/O缓冲数组长度 */
                void *msg_control;       /* 辅助数据 */
                socklen_t msg_controllen;/* 辅助数据的字节数 */
                int msg_flags;           /* 接受消息标志 */
            };
            ```
            + `flags`：同上；

16. 获取主机名字：
    ```C
    #include <unistd.h>
    int gethostname(char *name, size_t namelen);
    int sethostname(const char *name, size_t len);
    ```
    + 功能：获取当前机器的标准主机名

    + 返回值： 

        + 成功： 返回0；

        + 失败： 返回-1，设置errno


参考链接：
    [Linux环境进程间通信（一）](https://www.ibm.com/developerworks/cn/linux/l-ipc/part1/index.html#b)


[pipe1]:../img/IPCs/pipe1.PNG
[pipe2]:../img/IPCs/pipe2.PNG
[pipe3]:../img/IPCs/pipe3.PNG
[popen1]:../img/IPCs/popen1.PNG
[popen2]:../img/IPCs/popen2.PNG
[coprocess]:../img/IPCs/coprocess.PNG